# Benefits of Test Driven Development

Test Driven Development is the practice of writing a test for a piece of functionality that is required before writing any implementation code. This test should fail when first run. Then, you write the code to get it to pass. It doesn't have to be the most perfect code. Just so long as the test passes. Once it does, you can then safely refactor your code.

TDD is a discipline. You must try your best to not be tempted to write tests later. Pressure can come from clients or employers to delay or not bother with the writing the tests at all. First of all they need to understand the benefits of tests, and then the additional benefits of TDD on top so you can secure that time to practice TDD correctly. **Point to some links that help explain the benefits to client, employer, or X? Out of this posts scope...**

If your application has tests that weren't written before the code that implements them, then that means TDD wasn't followed. It does mean however that your project has test coverage, which is a good thing that has many benefits—definitely better than not having any tests—but practising TDD brings additional benefits on top of those. Often some articles on the internet claim to write about those additional benefits but instead seem to end up focusing on the benefits of tests in general. This post will try and focus strictly on the benefits of TDD.

You shouldn't assume either that TDD doesn't mix with BDD. The key is writing the tests before the code. When writing feature specs that define the behaviour of something, if you're writing those specifications before implementing them, you're TDD'ing too.

At Made, we use TDD when writing our feature specs. We use tools most commonly used for unit tests for our feature tests too, rather than things like Cucumber, which are often associated with BDD. You can still use Cucumber for example for feature specs, and TDD.

## Benefits

 * **Acceptance criteria:** When writing some new code, you usually have a list of features that are required, or acceptance criteria that needs to be met. You can use either of these as a means to know what you need to test and then you can rest assured once you've got that list in the form of test code, that you won't have missed any work.
 * **Focus:** You'll be more productive while coding. You're thinking about smaller chunks of functionality at a time. You write one failing test, and focus on that solely, to get it passing. You can then slowly build on a passing test incrementally rather than trying to tackle the bigger picture from the get-go, which will probably result in more bugs, and therefore a longer development time.
 * **Interfaces:** Because you're writing a test for a single piece of functionality, writing a test first means you think of the public interface that other code in your application has to integrate with. You don't think about the private methods or inner workings of what you're about to work on. From the tests perspective, you're only writing method calls to test the public methods. This means that code will read well and make more sense.
 * **Tidier code:** Continuing on from the point above, your tests are only interfacing with public methods, so you have a much better idea of what can be made private, meaning you don't accidentally expose methods that don't need to be. If you weren't TDD'ing, and you made a method as public, you'd then possibly have to support that in the future, meaning more work for you for a method that was only intended to be used internally in a class.
 * **Dependencies:** **FOR NEXT WEEKS BLOG HOUR:** What will your new functionality depend on? Means you can mock those dependencies in your test, which means your tests are only ever actually testing that one piece of code you write.
 * **Safer refactoring:** Once you've got a test passing, it's then safe to refactor it, knowing that the test cases will have your back. If you're having to work with legacy code, or code that someone else has written, if no tests have been written, you can still practice TDD. You haven't got to have authored the original code in order for you to TDD. Rather than thinking you can only TDD code that you have written, think of it more as you can only TDD any code you are _about_ to write. So if you inherit someone elses untested code, before you start work, write a test that covers as much as you can. Then you can be in a better position to refactor, or add new functionality to that code feeling safer that you won't break anything.
 * **Pairing:** When teaming up with another developer, TDD can help ensure that both are on the same page when it comes to figuring out what they're working on. You both write tests that are clear on what the code code function expectations are. It also helps onboard people quicker who might be pairing with you, that aren't familiar with the code base, as expectations and assertions are clear.
 * **Less bugs:** TDD results in more tests, which can often result in longer test run times, however, with better code coverage, you save time down the line with bugs popping up that need time to figure out what's wrong and fix. Not to say that you might be able to think of all the things to test, but if a bug does come up, you can still write a test first before attempting to fix the problem, to be sure that the bug won't come up again. This also helps to work out what a bug actually is, as you always need reproducible steps.
