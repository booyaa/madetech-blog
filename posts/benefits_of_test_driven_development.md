# Benefits of Test Driven Development

 * Brief intro to TDD and how just having tests for your application doesn't mean you have used TDD.
 * With TDD, you strictly write your tests for a piece of functionallity before you write the code that implements it. Before. Not after.
 * You shouldn't assume either that TDD doesn't mix with BDD. The key is writing the tests before the code. When writing feature specs that define the behaviour of something, if you're writing those specifications before implementing them, you're TDD'ing too.
 * At Made, we use TDD when writing our feature specs. We use tools most commonly used for unit tests for our feature tests too, rather than things like Cucumber, which are often associated with BDD. You can still use Cucumber for example for feature specs, and TDD.
 * Often, articles that claim to write about the benefits of TDD sometimes write about just the benefits of having tests in general. This post will try and focus on the benefits of following TDD strictly, where you write the test first. Tests that are written after something has been implemented ensure that the code is covered, to minimise regressions, which is still better than no tests at all, however, you miss out on the benefits listed in this post.
 * TDD is a discipline. You must try your best to not be tempted to write tests later. Pressure can come from clients or employers to delay or not bother with the writing the tests at all. First of all they need to understand the benefits of tests, and then the additional benefits of TDD on top so you can secure that time to practice TDD correctly.

## Benefits

 * Acceptance criteria; when writing some new code, there is a reason for doing so. You have a list of features it is required to perform or acceptance criteria that can be used. You can use these as a means to know what you need to test. And then you can rest assured that once you've got that list in the form of test code, that you won't have missed any work.
 * Focus; this means you'll be more productive. You're thinking about smaller chunks of functionallity at a time. You write one failing test, and focus on getting that solely, to pass. **More on this**
 * Interfaces; because your writing a test for a single piece of functionallity, writing a test first means you think of the public interface that other code in your application has to work with. You don't think about the private methods or inner workings of what you're about to work on. From the tests perspective, you're only writing method calls to the public methods other code will work with. This means that code will read well and make more sense.
 * Tidier code; because you're only interfacing with public methods, you have a better idea of what can be made private meaning you don't expose methods to that don't need to be. If you weren't TDD'ing, and you accidentally exposed a method as public, you'd then possibly have to support that in the future, meaning more work for you for a method that was only intended to be used internally in a class.
 * Safer refactoring; once you have got a test passing, you're then safe to refactor it, knowing that the test cases will have your back. If you're having to work with legacy code, or code that someone else has written, if no tests have been written, you can still practice TDD. You haven't got to have authored the original code in order for you to TDD. Rather than thinking you can only TDD code you have written, think of it more as you can only TDD any code you are to write. So if you inherit someone elses untested code, before you start work, write a test that covers as much as you can. Then you can be in a better position to refactor, or add new functionallity to that code feeling safer that you won't break anything.
 * When pairing, TDD can help ensure that both developers are on the same page when it comes to figuring out what they're working on. You both write tests that are clear on what the code code function expectations are. It also helps onboard people quicker who might be pairing with you, that aren't familiar with the code base, as expectations and assertions are clear.
 * Less buggy code; TDD results in more tests, which can often result in longer test run times, however, with better code coverage, you save time down the line with bugs popping up that need time to figure out what's wrong and fix. Not to say that you might be able to think of all the things to test, but if a bug does come up, you can still write a test first before attempting to fix the problem, to be sure that the bug won't come up again. This also helps to work out what a bug actually is, as you always need reproducible steps.
